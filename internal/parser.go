package internal

import (
	"encoding/json"
	"encoding/xml"
	"fmt"
	"html"
	"io"
	"net/http"
	"strings"

	"github.com/elbombardi/yt_captions/models"
)

const youtubeBaseURL = "https://www.youtube.com/watch?v="

type ytInitialPlayerResponse struct {
	Captions struct {
		PlayerCaptionsTracklistRenderer struct {
			CaptionTracks []CaptionTrack `json:"captionTracks"`
		} `json:"playerCaptionsTracklistRenderer"`
	} `json:"captions"`
}

type CaptionTrack struct {
	BaseUrl      string `json:"baseUrl"`
	LanguageCode string `json:"languageCode"`
	VssId        string `json:"vssId"`
}

// Transcript represents the root <transcript> element.
type Transcript struct {
	Texts []Text `xml:"text"`
}

// Text represents a single <text> element in the transcript.
type Text struct {
	Start string `xml:"start,attr"`
	Dur   string `xml:"dur,attr"`
	Value string `xml:",chardata"`
}

func (track *CaptionTrack) toCaption() (*models.Caption, error) {
	caption := models.Caption{
		Language:        track.VssId,
		IsAutoGenerated: track.VssId[0] != '.',
	}

	transcript, err := loadTranscript(track)
	if err != nil {
		return nil, fmt.Errorf("unable to load transcript: %w", err)
	}

	// Convert to TimedText array
	var timedTexts []models.TimedText
	for _, text := range transcript.Texts {
		start, err := toMilliseconds(text.Start)
		if err != nil {
			fmt.Printf("Error converting start time: %v\n", err)
			continue
		}
		duration, err := toMilliseconds(text.Dur)
		if err != nil {
			fmt.Printf("Error converting duration: %v\n", err)
			continue
		}
		timedTexts = append(timedTexts, models.TimedText{
			Start: newTimeStamp(start),
			End:   newTimeStamp(start + duration),
			Text:  html.UnescapeString(text.Value),
		})
	}
	caption.TimedTexts = timedTexts
	return &caption, nil
}

type CaptionsParser struct {
	BaseURL string
}

func NewCaptionsParser() *CaptionsParser {
	return &CaptionsParser{
		BaseURL: youtubeBaseURL,
	}
}

func loadTranscript(captionTrack *CaptionTrack) (*Transcript, error) {
	resp, err := http.Get(captionTrack.BaseUrl)
	if err != nil {
		return nil, fmt.Errorf("unable to download caption: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("unable to read response body: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unable to download caption: %s, %s", resp.Status, string(body))
	}

	xml := string(body)
	return parseTranscript(xml)
}

func parseTranscript(xmlContent string) (*Transcript, error) {
	transcript := &Transcript{}
	err := xml.Unmarshal([]byte(xmlContent), transcript)
	return transcript, err
}

func loadCaptionTracks(videoID, baseURL string) ([]CaptionTrack, error) {
	resp, err := http.Get(baseURL + videoID)
	if err != nil {
		return nil, fmt.Errorf("unable to download video page: %w", err)
	}

	defer resp.Body.Close()

	content, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("unable to read response body: %w", err)
	}

	pageContent := string(content)

	// Find ytInitialPlayerResponse variable
	pageContentSplited := strings.Split(pageContent, "ytInitialPlayerResponse = ")
	if len(pageContentSplited) < 2 {
		return nil, fmt.Errorf("unable to find ytInitialPlayerResponse variable")
	}

	// Find the end of the variable (TODO Needs more attention)
	pageContentSplited = strings.Split(pageContentSplited[1], ";</script>")
	if len(pageContentSplited) < 2 {
		return nil, fmt.Errorf("unable to find the end of the ytInitialPlayerResponse variable")
	}

	ytInitialPlayerResponse := ytInitialPlayerResponse{}
	err = json.Unmarshal([]byte(pageContentSplited[0]), &ytInitialPlayerResponse)
	if err != nil {
		return nil, fmt.Errorf("unable to unmarshal ytInitialPlayerResponse: %w", err)
	}

	return ytInitialPlayerResponse.Captions.PlayerCaptionsTracklistRenderer.CaptionTracks, nil
}

func (c *CaptionsParser) getCaptions(videoID string) ([]*models.Caption, error) {
	tracks, err := loadCaptionTracks(videoID, c.BaseURL)
	if err != nil {
		return nil, fmt.Errorf("unable to list video captions: %w", err)
	}
	captions := make([]*models.Caption, 0)

	// load each track
	for _, track := range tracks {
		caption, err := track.toCaption()
		if err != nil {
			return nil, err
		}
		captions = append(captions, caption)
	}
	return captions, nil
}

func (c *CaptionsParser) GetAllCaptions(videoID models.VideoID) ([]*models.Caption, error) {
	id, err := videoID.GetID()
	if err != nil {
		return nil, fmt.Errorf("unable to get video ID: %w", err)
	}
	return c.getCaptions(id)
}

func (c *CaptionsParser) GetLanguages(videoID models.VideoID) ([]string, error) {
	id, err := videoID.GetID()
	if err != nil {
		return nil, fmt.Errorf("unable to get video ID: %w", err)
	}
	tracks, err := loadCaptionTracks(id, c.BaseURL)
	if err != nil {
		return nil, fmt.Errorf("unable to list video captions: %w", err)
	}
	var languages []string
	for _, track := range tracks {
		languages = append(languages, track.VssId)
	}
	return languages, nil
}

func (c *CaptionsParser) GetCaptions(videoID models.VideoID, lang string) (*models.Caption, error) {
	id, err := videoID.GetID()
	if err != nil {
		return nil, fmt.Errorf("unable to get video ID: %w", err)
	}
	tracks, err := loadCaptionTracks(id, c.BaseURL)
	if err != nil {
		return nil, fmt.Errorf("unable to list video captions: %w", err)
	}
	for _, track := range tracks {
		if track.VssId == lang {
			return track.toCaption()
		}
	}
	return nil, fmt.Errorf("no captions found for language: %s", lang)

}
